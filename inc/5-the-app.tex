\subsection{Разработка функционала приложения}

Функционал приложения включает:
\begin{enumerate}
	\item расшифровку кода скриптов (скрипта) Lua;
	\item инициализацию Lua;
	\item регистрацию собственных функций, в том числе в пространствах имен;
	\item запуск строки скрипта на исполнение.
\end{enumerate}

Алгоритм работы в подробностях:

В начале программы происходит расшифровка скрипта, который был зашифрован для защиты или уменьшения размера. Для этого используется функция Decrypt, которая принимает зашифрованные данные (в данном случае скрипт Lua) и расшифровывает их с помощью алгоритма AES в режиме CBC.

Следующий этап -- инициализация среды Lua с помощью luaL\_newstate. Это создает новый объект lua\_State, который представляет собой состояние Lua, в котором будут выполняться скрипты.

Далее регистрируются функции C++ в Lua, что позволяет Lua-скрипту вызывать их. В частности, функции, которые были объявлены в пространстве LuaFunctions, такие как функция таймера, выполнение команд в оболочке (bash) и другие полезные функции. Функции добавляются в Lua через LuaFunctions::Register.

После расшифровки и инициализации среды Lua, скрипт выполняется с помощью luaL\_dostring. Эта функция интерпретирует и выполняет Lua-код, переданный в виде строки.

После того как скрипт выполнен, можно вызывать Lua-функции из C++. Для этого используется несколько шагов:
\begin{itemize}
	\item Получение глобальной функции с помощью lua\_getglobal(L, "FunctionName"). Это помещает функцию в стек Lua.
	\item Пуш аргументов (если необходимо) в стек Lua, используя, например, lua\_pushnumber для числовых значений.
	\item Вызов функции с помощью lua\_pcall(L, numArgs, numResults, 0), где numArgs -- это количество аргументов, передаваемых функции, а numResults -- количество ожидаемых результатов.
	\item Чтение результата из стека Lua с помощью функций, таких как lua\_tonumber, lua\_toboolean и так далее.
\end{itemize}

Пример вызова Lua-функции IsWindows из C++:
\addmyimage{images/1-1-5.png}{}{Вызов Lua-функции IsWindows из C++}

Завершающий этап -- очистка. После завершения работы с Lua нужно закрыть состояние Lua, используя lua\_close(L), чтобы освободить все ресурсы, связанные с этим состоянием. Также удалить массив с расшифрованным скриптом.

\clearpage